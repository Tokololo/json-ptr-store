{"version":3,"sources":["../src/store.ts","../src/library.ts"],"sourcesContent":["import { BehaviorSubject, filter, map, Observable, takeWhile } from \"rxjs\";\nimport { isArray, isPlainObject } from \"lodash\";\nimport { cloneJson, distinctUntilChangedEq, longestCommonPrefix, ptrGet, ptrRemove, ptrSet, removeDeepUndefined, strictnessEqualComparer, strictnessType, customStrictnessComparerType } from \"./library\";\n\ninterface IStoreValue { [tag: string]: any }\ninterface IStorePtr { ptr: string, value: any }\ninterface IStoreFlags<Strictness extends string = strictnessType> {\n    nextTick?: boolean,\n    strictness?: Strictness\n}\n\nconst flagValue = (flag1?: boolean, flag2?: boolean) =>\n    typeof flag1 === 'boolean' ?\n        flag1 :\n        flag2;\n\nexport { strictnessEqualComparer, strictnessType }\n\nexport class Store<Strictness extends string = strictnessType> {\n\n    private _sub = new BehaviorSubject<{ last_set_ptrs: string[], value: IStoreValue }>({ last_set_ptrs: [], value: {} });\n    private _running = true;\n\n    /**\n     * Store Constructor\n     * @param initial Optional initial object literal value to seed the store with\n     * @param _flags Optional flags: { nextTick?: boolean, strictness?: string }. Default is { nextTick?: false, strictness?: 'none' }\n     * @param _comparer Optional supplemental comparer to use with a custom defined strictness: (obj1: any, obj2: any, strictness: string) => boolean\n     */\n    constructor(\n        initial?: IStoreValue,\n        private _flags?: IStoreFlags<Strictness>,\n        private _comparer?: customStrictnessComparerType<Strictness>) {\n\n        this._flags = this._flags || {};\n\n        if (!this._flags?.strictness)\n            this._flags.strictness = 'none' as Strictness;\n\n        if (initial)\n            this._sub.next({ last_set_ptrs: ['/'], value: isPlainObject(initial) ? initial : {} });\n\n    }\n\n    private _setDel(sets: IStorePtr[], dels: string[]) {\n        const val = this._sub.value.value;\n        sets.forEach(datum => ptrSet(val, datum.ptr, datum.value));\n        dels.forEach(ptr => ptrRemove(val, ptr));\n        const ptrs = [...sets.map(s => s.ptr), ...dels];\n        if (ptrs.length)\n            this._sub.next({ last_set_ptrs: ptrs, value: val });\n    }\n\n    /**\n     * Set and delete json pointer path values\n     * @param sets The json pointer path values to set: { ptr: string, value: any }[]\n     * @param dels The json pointer paths to delete: string[]\n     * @param flags Flags to control the bahavior: { nextTick?: boolean }. If nextTick is set it is done on a timeout.\n     */\n    setDel(sets: IStorePtr[], dels: string[], flags?: { nextTick?: boolean }) {\n\n        if (flagValue(flags?.nextTick, this._flags?.nextTick))\n            setTimeout(() => this._setDel(sets, dels), 0);\n        else\n            this._setDel(sets, dels);\n\n    }\n\n    private _set(data: IStorePtr[]) {\n\n        const val = this._sub.value.value;\n        data.forEach(datum => ptrSet(val, datum.ptr, datum.value));\n        const ptrs = data.map(s => s.ptr);\n        if (ptrs.length)\n            this._sub.next({ last_set_ptrs: ptrs, value: val });\n\n    }\n\n    /**\n     * Set json pointer path values\n     * @param data The pointer path values to set: { ptr: string, value: any }[]\n     * @param flags Flags to control the bahavior: { nextTick?: boolean }. If nextTick is set it is done on a timeout.\n     */\n    set(data: IStorePtr[], flags?: { nextTick?: boolean }) {\n\n        if (flagValue(flags?.nextTick, this._flags?.nextTick))\n            setTimeout(() => this._set(data), 0);\n        else\n            this._set(data);\n\n    }\n\n    private _del(ptrs: string[], atomic?: boolean) {\n\n        const val = this._sub.value.value;\n\n        if (atomic) {\n            ptrs.forEach(ptr => ptrSet(val, ptr, undefined));\n            const ptr = longestCommonPrefix(ptrs);\n            const value = removeDeepUndefined(ptrGet(val, ptr), true);\n            this.set([{ ptr, value }]);\n        }\n        else {\n            ptrs.forEach(ptr => ptrRemove(val, ptr));\n            this._sub.next({ last_set_ptrs: ptrs, value: val });\n        }\n\n    }\n\n    /**\n     * Delete pointer path values in the store\n     * @param ptrs An array of pointer paths to delete\n     * @param flags Flags to control the bahavior: { nextTick?: boolean, atomic?: boolean }. If nextTick is set it is done on a timeout. If atomic is set pointer operations only take effect on completion of all operations.\n     */\n    del(ptrs: string[], flags?: { nextTick?: boolean, atomic?: boolean }) {\n\n        if (flagValue(flags?.nextTick, this._flags?.nextTick))\n            setTimeout(() => this._del(ptrs, flags?.atomic), 0);\n        else\n            this._del(ptrs, flags?.atomic);\n\n    }\n\n    /**\n     * Assign array/object literal values to the store \n     * @param data The pointer paths with its array/object literals: { ptr: string, value: any[] | Object }\n     * @param nextTick If set the operation is done on a timeout \n     */\n    assign(data: { ptr: string, value: any[] | Object }, nextTick?: boolean) {\n\n        const val = this.slice(data.ptr);\n        if (isArray(val) && isArray(data.value))\n            this.set([{ ptr: data.ptr, value: [...val, ...data.value] }], { nextTick });\n        else if (isPlainObject(val) && isPlainObject(data.value))\n            this.set([{ ptr: data.ptr, value: { ...val, ...data.value } }], { nextTick });\n        else\n            this.set([data], { nextTick });\n\n    }\n\n    /**\n     * Get an observable that is updated when the pointer path value changes\n     * @param ptr The json pointer path\n     * @param strictness Override store configured strictness\n     * @returns An observable that emits on changes at the json pointer path\n     */\n    get<T = any>(ptr: string, strictness?: Strictness): Observable<T> {\n\n        let n = 0;\n\n        return this._sub.pipe(\n            takeWhile(_ => !!this._running),\n            filter(value =>\n                (n++ == 0) ||\n                (value.last_set_ptrs.some(lptr => lptr.indexOf(ptr) == 0 || ptr.indexOf(lptr) == 0))),\n            map(value => ptrGet<T>(value.value, ptr)),\n            distinctUntilChangedEq<T, Strictness>(strictness || this._flags!.strictness!, this._comparer)\n        );\n\n    }\n\n    /**\n     * Get a slice from the store at a json pointer path\n     * @param ptr The json pointer path\n     * @param clone True to return a cloned slice\n     * @param defaultValue The default value to return if no value is found\n     * @returns The value found at the ptr\n     */\n    slice<T = any>(ptr: string, clone?: boolean, defaultValue?: T): T | undefined {\n\n        const value = ptrGet<T>(this._sub.value.value, ptr);\n        return clone ? cloneJson<T | undefined>(typeof value != 'undefined' ? value : defaultValue) : (typeof value != 'undefined' ? value : defaultValue);\n\n    }\n\n    /**\n     * Initialise the store with new values\n     * @param value An object literal\n     */\n    initialise(value: IStoreValue) {\n\n        this._sub.next({ last_set_ptrs: ['/'], value });\n\n    }\n\n    /**\n     * Release all subscriptions into the store\n     */\n    destroy() {\n\n        this._running = false;\n        this._sub.next({ last_set_ptrs: ['/'], value: {} });\n\n    }\n\n}","import { remove, get, set, has } from 'json-pointer';\nimport { cloneDeep, isArray, isEqual, isPlainObject, mapValues } from 'lodash';\nimport { distinctUntilChanged } from 'rxjs';\nimport { CleanOptions } from 'clean-deep';\nconst cleanDeep = require('clean-deep');\nconst sortAny = require('sort-any');\n\nconst CLEAN_DEEP_OPTS = {\n    emptyArrays: true,\n    emptyObjects: true,\n    emptyStrings: true,\n    NaNValues: false,\n    nullValues: true,\n    undefinedValues: true\n}\n\nconst voidObject = (source: any, val: any) => {\n\n    Object.keys(source).forEach(key => delete source[key]);\n    Object.assign(source, val);\n\n}\n\nconst sortDeep = (obj: any): any => {\n\n    if (!isArray(obj)) {\n\n        if (!isPlainObject(obj))\n            return obj;\n\n        return mapValues(obj, sortDeep);\n\n    }\n\n    return sortAny(obj.map(sortDeep));\n\n};\n\n/**\n * The strictness values used by the default comparer\n */\nexport type strictnessType = 'isEqualRemoveUndefinedSorted' | 'isEqualRemoveUndefined' | 'isEqual' | 'strict' | 'none';\nexport type strictnessComparerType<Stricktness extends string = strictnessType> = (obj1: any, obj2: any, strictness: strictnessType, comparer?: customStrictnessComparerType<Stricktness>) => boolean;\nexport type customStrictnessComparerType<Stricktness extends string> = (obj1: any, obj2: any, strictness: Stricktness) => boolean;\n\nexport const longestCommonPrefix = (ptrs: string[]) => {\n\n    if (!ptrs.length) return '/';\n\n    let prefixParts = ptrs[0].split('/');\n\n    for (let i = 1; i < ptrs.length; i++) {\n\n        const iPrefixParts = ptrs[i].split('/');\n\n        let j = 0;\n        while (prefixParts[j] == iPrefixParts[j])\n            j++;\n\n        prefixParts = prefixParts.slice(0, j);\n\n    }\n\n    return prefixParts.length === 1 ? '/' : prefixParts.join('/');\n}\n\nexport const removeDeepUndefined = <T>(obj: T, no_clone?: boolean, options?: CleanOptions): T => {\n\n    return cleanDeep(no_clone ? obj : cloneJson(obj), options || CLEAN_DEEP_OPTS) as any;\n\n}\n\n/**\n * Compare two objects taking strictness constraint into consideration\n * @param obj1 \n * @param obj2 \n * @param strictness One of 'isEqualRemoveUndefinedSorted' | 'isEqualRemoveUndefined' | 'isEqual' | 'strict' | 'none', or string if using custom\n * @param comparer A custom comparer to use with a custom strictness that supplements the default comparer.\n * @returns \n */\nexport const strictnessEqualComparer = <Strictness extends string = strictnessType>(\n    obj1: any,\n    obj2: any,\n    strictness: Strictness = 'none' as Strictness,\n    comparer?: customStrictnessComparerType<Strictness>): boolean => {\n\n    if (strictness === 'none')\n        return false;\n    if (typeof obj1 == 'undefined' && typeof obj2 == 'undefined')\n        return true;\n    if (typeof obj1 == 'undefined' || typeof obj2 == 'undefined')\n        return false;\n    if (strictness === 'strict')\n        return obj1 === obj2;\n\n    if (strictness == 'isEqual')\n        return isEqual(\n            obj1,\n            obj2);\n    else if (strictness == 'isEqualRemoveUndefined')\n        return isEqual(\n            removeDeepUndefined(obj1),\n            removeDeepUndefined(obj2));\n    else if (strictness == 'isEqualRemoveUndefinedSorted')\n        return isEqual(\n            sortDeep(removeDeepUndefined(obj1)),\n            sortDeep(removeDeepUndefined(obj2)));\n    else if (comparer)\n        return comparer(obj1, obj2, strictness);\n    else\n        return false;\n\n}\n\nexport const distinctUntilChangedEq = <T, Strictness extends string = strictnessType>(\n    strictness: Strictness = 'none' as Strictness,\n    comparer?: customStrictnessComparerType<Strictness>) => distinctUntilChanged<T>((a, b) => strictnessEqualComparer(a, b, strictness, comparer));\n\nexport const ptrGet = <T>(source: any, ptr: string): T => {\n\n    return ptr === '/' ?\n        source :\n        get(source, ptr);\n\n}\n\nexport const ptrSet = (source: any, ptr: string, val: any) => {\n\n    try {\n\n        return ptr === '/' ?\n            voidObject(source, val) :\n            set(source, ptr, val);\n\n    }\n    catch { }\n\n}\n\nexport const ptrHas = (source: any, ptr: string) => {\n\n    try {\n\n        return ptr === '/' ?\n            typeof source != 'undefined' :\n            has(source, ptr);\n\n    }\n    catch { }\n\n}\n\nexport const ptrRemove = (source: any, ptr: string) => {\n\n    try {\n\n        remove(source, ptr);\n\n    }\n    catch { }\n\n}\n\nexport function cloneJson<T>(value: T): T | undefined {\n\n    try {\n\n        if (typeof value == 'undefined')\n            return undefined;\n\n        return cloneDeep<T>(value);\n\n    }\n    catch (error) {\n\n        throw error;\n\n    }\n\n}"],"mappings":"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","names":["isArray","isPlainObject","isPlainObject","ptr","isArray"]}